The hardware queue scheduling is apparently configured with fixed
priorities, which creates a nasty fairness issue where traffic from one
CPU can starve traffic from all other CPUs.

Work around this issue by forcing all tx packets to go through one CPU,
until this issue is fixed properly.

Signed-off-by: Felix Fietkau <nbd@nbd.name>
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -5046,6 +5046,16 @@ static int mvneta_ethtool_set_eee(struct
 	return phylink_ethtool_set_eee(pp->phylink, eee);
 }
 
+#ifndef CONFIG_ARM64
+static u16 mvneta_select_queue(struct net_device *dev, struct sk_buff *skb,
+			       struct net_device *sb_dev)
+{
+	/* XXX: hardware queue scheduling is broken,
+	 * use only one queue until it is fixed */
+	return 0;
+}
+#endif
+
 static void mvneta_clear_rx_prio_map(struct mvneta_port *pp)
 {
 	mvreg_write(pp, MVNETA_VLAN_PRIO_TO_RXQ, 0);
@@ -5214,6 +5224,9 @@ static const struct net_device_ops mvnet
 	.ndo_fix_features    = mvneta_fix_features,
 	.ndo_get_stats64     = mvneta_get_stats64,
 	.ndo_eth_ioctl        = mvneta_ioctl,
+#ifndef CONFIG_ARM64
+	.ndo_select_queue    = mvneta_select_queue,
+#endif
 	.ndo_bpf	     = mvneta_xdp,
 	.ndo_xdp_xmit        = mvneta_xdp_xmit,
 	.ndo_setup_tc	     = mvneta_setup_tc,
